@startuml server-sequence

scale 0.7
skinparam responseMessageBelowArrow true
skinparam maxMessageSize 150
skinparam ParticipantPadding 80
skinparam BoxPadding 40

box "Client Side" #LightYellow
participant "Client" as client
end box

box "Server Core Components" #LightBlue
participant "Main" as main
participant "ServerThread" as sthread
participant "ShutdownThread" as shutdown
participant "Server" as server
participant "Logger" as logger
participant "Socket" as socket
participant "EpollWrapper" as epoll
participant "ThreadPool" as pool
participant "WorkerThread" as worker
participant "Router" as router
participant "Http" as http
participant "Cache" as cache
participant "RateLimiter" as limiter
participant "Compression" as compression
end box

== Server Initialization ==
[-> main: main()
activate main

main -> logger: getInstance()
activate logger
logger --> main: logger instance
deactivate logger

main -> Parser: parseConfig("pgs_conf.json")
activate Parser
Parser -> logger: info("Reading configuration")
Parser -> Parser: validate configuration
Parser -> logger: success("Configuration loaded")
Parser --> main: Config object
deactivate Parser

main -> server: new Server(config)
activate server

server -> socket: new Socket(port)
activate socket
socket -> logger: info("Creating socket")
socket -> socket: socket(AF_INET6, SOCK_STREAM, 0)
socket -> socket: setSocketOptions()
note right: SO_REUSEADDR | SO_REUSEPORT\nSO_SNDBUF | SO_RCVBUF
socket -> socket: setNonBlocking()
socket -> logger: success("Socket configured")
socket --> server: socket ready
deactivate socket

server -> pool: new ThreadPool(threadCount)
activate pool
pool -> logger: info("Initializing thread pool")
pool -> pool: initialize thread local data
note right: Create per-thread work stealing queues

create worker
pool -> worker: start N worker threads
activate worker

worker -> worker: setThreadName("worker-N")
worker -> worker: setThreadAffinity(N)

loop until stop_flag
    alt local_queue not empty
        worker -> worker: process task from local queue
    else try work stealing
        loop for each other worker
            worker -> worker: try_steal_task()
            alt steal successful
                worker -> worker: process stolen task
                break
            end
        end
    else try global queue
        worker -> pool: try_pop from global_queue
        alt got task
            worker -> worker: process task
        else
            worker -> worker: sleep(100Î¼s)
        end
    end
end

worker --> pool: worker ready
deactivate worker

pool -> logger: success("Thread pool ready")
pool --> server: thread pool ready
deactivate pool

== Main Event Loop ==
server -> server: initializeTimeouts()
note right: Pre-allocate vectors for\ntimeout tracking

server -> epoll: add(socket_fd, EPOLLIN)
activate epoll

loop until shouldStop
    epoll -> epoll: wait(events, MAX_EVENTS, 100ms)
    
    alt new connection
        server -> socket: acceptConnection()
        activate socket
        socket -> socket: accept()
        socket -> socket: setNonBlocking()
        socket -> logger: success("New connection")
        socket --> server: client_socket
        deactivate socket
        
        server -> epoll: add(client_socket, EPOLLIN | EPOLLET)
        
    else existing connection
        server -> pool: enqueue(handleClient)
        activate worker
        
        worker -> server: handleClient()
        activate server
        
        server -> server: readRequest()
        
        alt valid request
            server -> Http: parseRequest()
            activate http
            http -> router: route()
            activate router
            
            router -> cache: tryGet()
            alt cache hit
                cache --> router: cached response
                router -> compression: compress()
                router -> client: send response
            else cache miss
                router -> router: processRequest()
                router -> compression: compress()
                router -> cache: store()
                router -> client: send response
            end
            
            deactivate router
            deactivate http
        end
        
        server -> logger: info("Request completed")
        deactivate server
        deactivate worker
    end
end

== Request Processing ==
server -> worker: handleClient()
activate worker

worker -> server: handleClient(socket, ip)
activate server

server -> server: readRequest()

server -> Http: parseRequest()
activate http

http -> router: route()
activate router

router -> cache: tryGet()
alt cache hit
    cache --> router: cached response
    router -> compression: compress()
    activate compression
    compression --> router: compressed data
    deactivate compression
    
    router -> client: send response
else cache miss
    router -> router: processRequest()
    
    router -> compression: compress()
    activate compression
    compression --> router: compressed data
    deactivate compression
    
    router -> cache: store()
    router -> client: send response
end

deactivate http
deactivate router

server -> logger: info("Request completed")
deactivate server
deactivate worker

== Server Shutdown ==
[-> main: SIGINT/SIGTERM
main -> shutdown: create & set priority(-10)
activate shutdown

shutdown -> server: stop()
activate server

server -> logger: warning("Initiating shutdown")
server -> shouldStop: set true
server -> socket: closeSocket()
server -> pool: stop()

pool -> worker: notify all workers
worker -> worker: finish remaining tasks
worker --> pool: workers terminated

server -> server: collectSocketsToClose()

alt connections > PARALLEL_THRESHOLD
    server -> server: parallelClose()
    
    create "CloseThread[N]" as closeThread
    server -> closeThread: start N threads
    activate closeThread
    
    loop for each thread
        closeThread -> server: closeConnection(chunk)
        activate server
        
        server -> server: lock & update stats
        server -> epoll: remove(socket)
        server -> socket: close()
        server -> logger: info("Connection closed")
        
        server --> closeThread
        deactivate server
    end
    
    closeThread --> server: all connections closed
    deactivate closeThread
    
else
    loop for each socket
        server -> server: closeConnection()
        activate server
        server -> server: lock & update stats
        server -> epoll: remove(socket)
        server -> socket: close()
        server -> logger: info("Connection closed")
        deactivate server
    end
end

server -> logger: info("All connections closed")
server --> shutdown: shutdown complete
deactivate server

shutdown --> main: server stopped
deactivate shutdown

main -> logger: destroyInstance()
activate logger
logger -> logger: flush logs
logger -> logger: close file
logger --> main: logger destroyed
deactivate logger

[<-- main: exit(0)
deactivate main

@enduml