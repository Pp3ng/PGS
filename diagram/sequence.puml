@startuml server-sequence

skinparam responseMessageBelowArrow true
skinparam maxMessageSize 150
skinparam ParticipantPadding 40
skinparam BoxPadding 20

box "Client Side" #LightYellow
participant "Client" as client
end box

box "Server Core Components" #LightBlue
participant "Main" as main
participant "Server" as server
participant "Logger" as logger
participant "Socket" as socket
participant "EpollWrapper" as epoll
participant "ThreadPool" as pool
participant "Router" as router
participant "Http" as http
participant "Cache" as cache
participant "RateLimiter" as limiter
participant "Compression" as compression
end box

== Server Initialization ==
[-> main: main()
activate main

main -> logger: getInstance()
activate logger
logger --> main: logger instance
deactivate logger

main -> Parser: parseConfig("pgs_conf.json")
activate Parser
Parser -> logger: info("Reading configuration")
Parser -> Parser: validate configuration
Parser -> logger: success("Configuration loaded")
Parser --> main: Config object
deactivate Parser

main -> server: new Server(config)
activate server

server -> socket: new Socket(port)
activate socket
socket -> logger: info("Creating socket")
socket -> socket: socket(AF_INET6, SOCK_STREAM, 0)
socket -> socket: setSocketOptions()
socket -> logger: success("Socket configured")
socket --> server: socket ready
deactivate socket

server -> epoll: new EpollWrapper()
activate epoll
epoll -> epoll: epoll_create1(EPOLL_CLOEXEC)
epoll -> epoll: add(socket_fd, EPOLLIN | EPOLLET)
epoll --> server: epoll instance
deactivate epoll

server -> pool: new ThreadPool(threadCount)
activate pool
pool -> logger: info("Initializing thread pool")
pool -> pool: start(numThreads)
pool -> pool: setThreadAffinity()
pool -> logger: success("Thread pool initialized")
pool --> server: thread pool ready
deactivate pool

server -> cache: new Cache(sizeMB, maxAge)
activate cache
cache -> logger: info("Initializing cache")
cache -> cache: startCacheCleanup()
note right: Start background cleanup thread
cache -> logger: success("Cache initialized")
cache --> server: cache ready
deactivate cache

server -> limiter: new RateLimiter(maxRequests, timeWindow)
server -> router: new Router(staticFolder)
server -> logger: success("Server initialized")
server --> main: server ready
== Connection Handling Loop ==
main -> server: start()
activate server

loop until shouldStop
    alt Cache Cleanup (Background Thread)
        cache -> cache: periodicCleanup()
        activate cache
        loop for each cache entry
            cache -> cache: check expiration
            alt expired
                cache -> cache: remove entry
                cache -> logger: debug("Removed expired entry")
            end
        end
        cache -> logger: debug("Cache cleanup completed")
        deactivate cache
    end

    client -> socket: connection request
    socket -> epoll: event notification
    epoll -> server: new connection event
    
    server -> socket: acceptConnection()
    activate socket
    socket -> logger: info("New connection")
    socket --> server: client_socket, clientIp
    deactivate socket
    
    server -> pool: enqueue(handleClient)
    activate pool
    
    pool -> server: handleClient(client_socket, clientIp)
    activate server
    
    server -> server: readClientData()
    alt valid request received
        server -> Http: getRequestPath(request)
        activate http
        http --> server: path
        deactivate http
        
        server -> limiter: process(request)
        activate limiter
        
        alt not rate limited
            limiter --> server: processed request
            deactivate limiter
            
            server -> compression: new Compression()
            server -> router: route(path, client_socket, clientIp, compression, cache)
            activate router
            
            router -> Http: isAssetRequest(path)
            router -> cache: get(path)
            activate cache
            
            alt cache hit
                cache -> cache: check expiration
                alt not expired
                    cache --> router: cached content
                    router -> logger: info("Cache hit")
                    deactivate cache
                    
                    router -> Http: sendResponse(cached)
                    activate http
                    http -> compression: shouldCompress()
                    alt should compress
                        http -> compression: process()
                    end
                    http -> client: send response
                    http --> router: response sent
                    deactivate http
                else expired
                    cache -> cache: remove expired entry
                    cache -> logger: debug("Cache entry expired")
                    cache --> router: cache miss
                end
                
            else cache miss
                cache --> router: cache miss
                router -> logger: info("Cache miss")
                
                router -> Http: sendResponse(file)
                activate http
                http -> compression: shouldCompress()
                alt should compress
                    http -> compression: process()
                end
                http -> http: sendHeaders()
                http -> http: sendContent()
                http -> cache: set(path, content)
                http -> client: send response
                http --> router: response sent
                deactivate http
            end
            
            router -> logger: info("Request completed")
            router --> server: routing complete
            deactivate router
            
        else rate limited
            limiter --> server: 429 response
            server -> logger: warning("Rate limited")
            server -> client: send rate limit response
        end
        
    else invalid request
        server -> logger: error("Invalid request")
    end
    
    server -> server: closeConnection()
    deactivate server
    deactivate pool
end
== Server Shutdown ==
[-> main: signal(SIGINT/SIGTERM)
main -> server: stop()
activate server

server -> logger: warning("Initiating server shutdown")

server -> socket: closeSocket()
activate socket
socket -> logger: info("Stopping accept socket")
socket --> server: socket closed
deactivate socket

server -> pool: stop()
activate pool
pool -> logger: info("Stopping thread pool")
pool -> pool: joinWorkers()
pool --> server: workers stopped
deactivate pool

server -> cache: stopCacheCleanup()
activate cache
cache -> logger: info("Stopping cache cleanup")
cache -> cache: join cleanup thread
cache --> server: cleanup stopped
deactivate cache

server -> server: closeAllConnections()
activate server
loop for each active connection
    server -> server: closeConnection(socket)
    server -> logger: info("Connection closed")
end
deactivate server

server -> epoll: cleanup()
activate epoll
epoll -> logger: info("Cleaning up epoll")
epoll --> server: epoll cleaned
deactivate epoll

server -> logger: info("Server shutting down")
server --> main: server stopped
deactivate server

main -> logger: destroyInstance()
activate logger
logger -> logger: flush remaining logs
logger -> logger: close log file
logger --> main: logger destroyed
deactivate logger

[<-- main: exit(EXIT_SUCCESS)
deactivate main

@enduml