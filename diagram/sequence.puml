@startuml server-sequence

scale 0.7
skinparam responseMessageBelowArrow true
skinparam maxMessageSize 150
skinparam ParticipantPadding 60
skinparam BoxPadding 30

box "Client Side" #LightYellow
participant "Client" as client
end box

box "Server Core Components" #LightBlue
participant "Main" as main
participant "ServerThread" as sthread
participant "ShutdownThread" as shutdown
participant "Server" as server
participant "Logger" as logger
participant "Socket" as socket
participant "EpollWrapper" as epoll
participant "ThreadPool" as pool
participant "WorkerThread" as worker
participant "Router" as router
participant "Http" as http
participant "Cache" as cache
participant "RateLimiter" as limiter
participant "Compression" as compression
end box

== Server Initialization ==
[-> main: main()
activate main

main -> logger: getInstance()
activate logger
logger --> main: logger instance
deactivate logger

main -> Parser: parseConfig("pgs_conf.json")
activate Parser
Parser -> logger: info("Reading configuration")
Parser -> Parser: validate configuration
Parser -> logger: success("Configuration loaded")
Parser --> main: Config object
deactivate Parser

main -> server: new Server(config)
activate server

server -> socket: new Socket(port)
activate socket
socket -> logger: info("Creating socket")
socket -> socket: socket(AF_INET6, SOCK_STREAM, 0)
socket -> socket: setSocketOptions()
note right: SO_REUSEADDR | SO_REUSEPORT\nSO_SNDBUF | SO_RCVBUF
socket -> socket: setNonBlocking()
socket -> logger: success("Socket configured")
socket --> server: socket ready
deactivate socket

server -> socket: bind()
activate socket
socket -> socket: bind to port
socket -> logger: step(2, "Socket bound")
socket --> server
deactivate socket

server -> socket: listen()
activate socket
socket -> socket: listen(SOMAXCONN)
socket -> logger: step(3, "Listening")
socket --> server
deactivate socket

server -> epoll: new EpollWrapper()
activate epoll
epoll -> epoll: epoll_create1(EPOLL_CLOEXEC)
epoll --> server: epoll instance
deactivate epoll

server -> pool: new ThreadPool(threadCount)
activate pool
pool -> logger: info("Initializing thread pool")
pool -> pool: initialize thread local data
note right: Create per-thread work stealing queues

create worker
pool -> worker: start N worker threads
activate worker
worker -> worker: setThreadName("worker-N")
worker -> worker: setThreadAffinity(N)
note right: Pin each worker to specific CPU core

loop until stop_flag
    alt local_queue not empty
        worker -> worker: process task from local queue
    else try work stealing
        loop for each other worker
            worker -> worker: try_steal_task()
            alt steal successful
                worker -> worker: process stolen task
                break
            end
        end
    else try global queue
        worker -> pool: try_pop from global_queue
        alt got task
            worker -> worker: process task
        else
            worker -> worker: sleep(100Î¼s)
        end
    end
end

worker --> pool: worker ready
deactivate worker

pool -> logger: success("Thread pool ready")
pool --> server: thread pool ready
deactivate pool

server -> cache: new Cache(sizeMB, maxAge)
activate cache
cache -> logger: info("Initializing cache")
cache -> cache: startCacheCleanup()
note right: Start background cleanup thread
cache -> logger: success("Cache initialized")
cache --> server: cache ready
deactivate cache

server -> limiter: new RateLimiter(maxRequests, timeWindow)
server -> router: new Router(staticFolder)
server -> logger: success("Server initialized")
server --> main: server ready

create sthread
main -> sthread: create & pin to CPU0
activate sthread
note right: Set thread affinity to CPU0\nfor optimal performance

sthread -> server: start()
activate server

== Main Event Loop ==
server -> server: initializeTimeouts()
note right: Pre-allocate vectors for\ntimeout tracking

server -> epoll: add(socket_fd, EPOLLIN)
activate epoll

loop until shouldStop
    epoll -> epoll: wait(events, MAX_EVENTS, 100ms)
    
    alt system load is low
        server -> server: checkIdleTimeouts()
        note right: Check every 30s when\nnfds < MAX_EVENTS
        
        loop for each timed out connection
            server -> server: closeConnection()
            server -> logger: info("Timeout connection closed")
        end
    end
    
    alt epoll wait error
        alt errno == EINTR
            note right: Continue on interrupt
        else
            server -> logger: error("Epoll wait failed")
            break
        end
    end
    
    loop for i = 0 to nfds
        alt new connection (events[i].fd == server_socket)
            server -> socket: acceptConnection()
            activate socket
            socket -> socket: accept()
            socket -> socket: setNonBlocking()
            socket -> logger: success("New connection from IP")
            socket --> server: client_socket, clientIp
            deactivate socket
            
            server -> server: addConnectionInfo()
            note right: Lock & update connections map
            
            server -> epoll: add(client_socket, EPOLLIN | EPOLLET)
            note right: Edge-triggered mode
            
        else existing connection
            server -> server: getClientInfo()
            note right: Lock & get connection info
            
            server -> pool: enqueue(handleClient)
            activate worker
            
            worker -> server: handleClient()
            activate server
            
            server -> server: readRequest()
            note right: Non-blocking recv in chunks
            
            alt valid request
                server -> Http: parseRequest()
                server -> limiter: checkRateLimit()
                
                alt not rate limited
                    server -> router: route()
                    activate router
                    router -> cache: tryGet()
                    
                    alt cache hit
                        cache --> router: cached response
                        router -> compression: compress()
                        router -> client: send response
                    else cache miss
                        router -> router: processRequest()
                        router -> compression: compress()
                        router -> cache: store()
                        router -> client: send response
                    end
                    deactivate router
                else rate limited
                    server -> client: send 429 response
                end
            end
            
            server -> logger: info("Request completed")
            deactivate server
            deactivate worker
        end
    end
end

== Server Shutdown ==
[-> main: SIGINT/SIGTERM
main -> shutdown: create & set priority(-10)
activate shutdown

shutdown -> server: stop()
activate server

server -> logger: warning("Initiating shutdown")
server -> shouldStop: set true
server -> socket: closeSocket()
server -> pool: stop()

pool -> worker: notify all workers
worker -> worker: finish remaining tasks
worker --> pool: workers terminated

server -> server: collectSocketsToClose()
note right: Lock & gather all sockets

alt connections > PARALLEL_THRESHOLD
    server -> server: parallelClose()
    note right: Create thread pool for\nparallel connection closing
    
    create "CloseThread[N]" as closeThread
    server -> closeThread: start N threads
    activate closeThread
    
    loop for each thread
        closeThread -> server: closeConnection(chunk)
        activate server
        
        server -> server: lock & update stats
        server -> epoll: remove(socket)
        server -> socket: close()
        server -> logger: info("Connection closed")
        
        server --> closeThread
        deactivate server
    end
    
    closeThread --> server: all connections closed
    deactivate closeThread
    
else
    loop for each socket
        server -> server: closeConnection()
        activate server
        server -> server: lock & update stats
        server -> epoll: remove(socket)
        server -> socket: close()
        server -> logger: info("Connection closed")
        deactivate server
    end
end

server -> logger: info("All connections closed")
server --> shutdown: shutdown complete
deactivate server

shutdown --> main: server stopped
deactivate shutdown

main -> logger: destroyInstance()
activate logger
logger -> logger: flush logs
logger -> logger: close file
logger --> main: logger destroyed
deactivate logger

[<-- main: exit(0)
deactivate main

@enduml
